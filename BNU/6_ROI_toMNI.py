#!/usr/bin/env python3
import os
import subprocess
import argparse

# Predefined list of brain regions (corresponding to the JHU50 template)
BRAIN_REGIONS = [
    "MCP", "PCT", "GCC", "BCC", "SCC", "Fx",
    "CST_R", "CST_L", "ML_R", "ML_L", "ICP_R", "ICP_L",
    "SCP_R", "SCP_L", "CP_R", "CP_L", "ALIC_R", "ALIC_L",
    "PLIC_R", "PLIC_L", "RLIC_R", "RLIC_L", "ACR_R", "ACR_L",
    "SCR_R", "SCR_L", "PCR_R", "PCR_L", "PTR_R", "PTR_L",
    "SS_R", "SS_L", "EC_R", "EC_L", "CGC_R", "CGC_L",
    "CGH_R", "CGH_L", "Fx/ST_R", "Fx/ST_L", "SLF_R", "SLF_L",
    "SFOF_R", "SFOF_L", "IFOF_R", "IFOF_L", "UF_R", "UF_L",
    "TAP_R", "TAP_L"
]

def warp_roi(input_roi, output_roi, warp_file, ref_image):
    """
    Use FSL's applywarp to transform the ROI file from individual space to MNI space.
    
    :param input_roi: Path to the input ROI file in individual space.
    :param output_roi: Path to save the warped ROI file in MNI space.
    :param warp_file: Path to the warp file (fa2standard_warp.nii.gz) generated by FNIRT.
    :param ref_image: Reference image in MNI space (e.g., fa_standard_space.nii.gz).
    """
    cmd = f"applywarp -i {input_roi} -r {ref_image} -w {warp_file} -o {output_roi} --interp=nn"
    subprocess.run(cmd, shell=True, check=True)
    print(f"[INFO] Warped {input_roi} -> {output_roi}")

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--data_path", required=True,
                        help="Path to the data directory (contains the 'data' subfolder)")
    parser.add_argument("--roi_index", type=int, required=True,
                        help="ROI index to process (1-based index corresponding to BRAIN_REGIONS)")
    parser.add_argument("--max_cl_num", type=int, default=12,
                        help="Maximum number of clusters (default: 12)")
    parser.add_argument("--method", default="sc", choices=["sc", "kmeans", "simlr"],
                        help="Segmentation method (default: sc)")
    args = parser.parse_args()

    data_path = args.data_path
    roi_index = args.roi_index
    max_cl_num = args.max_cl_num
    method = args.method

    # Validate the ROI index
    if roi_index < 1 or roi_index > len(BRAIN_REGIONS):
        print(f"[ERROR] ROI index must be between 1 and {len(BRAIN_REGIONS)}.")
        return

    # Get the brain region name corresponding to the ROI index (1-based)
    region = BRAIN_REGIONS[roi_index - 1]
    print(f"[INFO] Processing brain region: {region} with method: {method}")

    os.chdir(data_path)

    # Define paths for transformation files
    warp_file = os.path.join("data", "fa2standard_warp.nii.gz")
    ref_image = os.path.join("data", "fa_standard_space.nii.gz")

    # Input directory: individual-space seed files are assumed to be in a folder named as "parcellation_{method}"
    input_dir = os.path.join("data", "probtrack_old", f"parcellation_{method}")
    # Output directory: create a folder for the chosen brain region in the MNI-space results directory
    output_dir = os.path.join("data", "probtrack_old", f"parcellation_{method}_MNI", region)
    os.makedirs(output_dir, exist_ok=True)

    # Loop over cluster numbers (k from 2 to max_cl_num) and warp each file.
    for k in range(2, max_cl_num + 1):
        input_roi = os.path.join(input_dir, f"seed_{roi_index}_{k}.nii.gz")
        if not os.path.isfile(input_roi):
            print(f"[WARNING] Input ROI file not found: {input_roi}, skipping k={k}.")
            continue
        output_roi = os.path.join(output_dir, f"seed_{k}.nii.gz")
        warp_roi(input_roi, output_roi, warp_file, ref_image)

    print(f"[INFO] ROI-to-MNI processing completed for region {region}.")

if __name__ == "__main__":
    main()
